NOTE "CREATOR" "FlashPro Version: v2023.1";
NOTE "CAPTURE" "2023.1.0.6";
NOTE "DEVICE" "MPF300T";
NOTE "PACKAGE" "MPF300T-fcg1152";
NOTE "DATE" "2025/01/02";
NOTE "TIME" "16:01:31";
NOTE "STAPL_VERSION" "JESD71";
NOTE "VENDOR" "Microsemi Corporation";
NOTE "IDCODE" "0F8131CF";
NOTE "IDMASK" "0FFFFFFF";
NOTE "DESIGN" "fpga";
NOTE "DESIGN_DIRECTORY" "";
NOTE "DESIGN_VERSION" "";
NOTE "CHECKSUM" "34E0";
NOTE "SECURITY" "Disable";
NOTE "ALG_VERSION" "1";
NOTE "MAP_VERSION" "0";
NOTE "TOOL_VERSION" "1";
NOTE "MAX_FREQ" "25000000";
NOTE "SILSIG" "00000000";
NOTE "SPEED_GRAD" "STD";
NOTE "TEMP_GRAD" "IND";
NOTE "PLAYER_VERSION_VARIABLE" "PLAYERVERSIONVARIABLE";
NOTE "PLAYER_VERSION_SW_VARIABLE" "PLAYERVERSIONSWVARIABLE";
NOTE "BITSTREAM_DIGEST" "766F3BDDB514B0A391327C97B912E41F0F9D26586C6EB478E90FC0878D6157FA";

ACTION ZEROIZE_LIKE_NEW = 
       INIT_VARIABLES_FOR_ACTION,
       VERIFY_IDCODE,
       DO_CHECK_CYCLE_COUNT,
       DO_ZEROIZE_LIKE_NEW,
       DO_EXIT;
ACTION VERIFY_DIGEST = 
       INIT_VARIABLES_FOR_ACTION,
       VERIFY_IDCODE,
       PROC_ENABLE,
       DO_VERIFY_DIGEST,
       DO_EXIT;
ACTION READ_IDCODE = 
       INIT_VARIABLES_FOR_ACTION,
       SET_READ_IDCODE,
       VERIFY_IDCODE,
       DO_READ_CERTIFICATE,
       DO_EXIT;
ACTION DEVICE_INFO = 
       INIT_VARIABLES_FOR_ACTION,
       SET_DEVICE_INFO_ACTIONTYPE,
       VERIFY_IDCODE,
       DO_READ_CERTIFICATE,
       DO_DEVICE_INFO,
       DO_EXIT;
ACTION READ_DEVICE_CERTIFICATE = 
       SET_READ_DEV_CERT_ACTIONTYPE,
       DO_READ_CERTIFICATE,
       DO_DISPLAY_CERTIFICATE,
       DO_EXIT;



DATA PARAMETERS;
    INTEGER FREQ =4;
ENDDATA;

DATA GV;
    BOOLEAN ID[32];
    BOOLEAN PASS = 1;
    BOOLEAN BUFF32[32];
    INTEGER ALGO_VERSION =2;
    INTEGER STATUS =0;
    INTEGER DATAINDEX =0;
    INTEGER ICURNUMOFCOMPONENTS =0;
    INTEGER ICURCOMPONENTNO =0;
    INTEGER COMPONENTNO =0;
    INTEGER BLOCKNO =0;
    INTEGER CURRNUMOFBLOCKS =0;
    BOOLEAN DATA_SHIFT_RESULT[128];
    INTEGER IPOLL =0;
    INTEGER BPGMMODE =0;
    INTEGER BREADIDCODE =0;
    INTEGER I =0;
    INTEGER IBLOCKS =0;
    BOOLEAN SHARED_BUFFER[32768];
    INTEGER RANPROGRAMMINGACTION =0;
    BOOLEAN ONLY_CHECK_UKDIGEST0 = 0;
    BOOLEAN SMK_INITIALIZED = 0;
    BOOLEAN JTAG_DIS = 0;
    BOOLEAN ACT_UROW_ALGO_VERSION[6] = $01;
    BOOLEAN ACT_UROW_PGM_TYPE[4];
    BOOLEAN ACT_UROW_SW_VERSION[7];
    BOOLEAN ACT_UROW_PROGRAM_SW[4];
    BOOLEAN ACT_UROW_PGM_SW[3];
    INTEGER HEX[16] = 70,69,68,67,66,65,57,56,55,54,53,52,51,50,49,48;
    BOOLEAN PGMMODE[8];
    BOOLEAN ZMODE[2];
    BOOLEAN DATA_STATUS_RESULT[64];
    BOOLEAN KEYHI_REG[128];
    BOOLEAN KEYLO_REG[128];
    BOOLEAN IDCODEVALUE[32] = $0f8131cf;
    BOOLEAN IDMASK[32] = $0fffffff;
    INTEGER IDREV;
    INTEGER IDFAB;
    BOOLEAN BSRPATTERN[1634] = $240a49249249249249249249249249249249249249249249
        249249249249249249249249249249249249249249249249249249249249249000000000
        000000000000092492492492492492492492492492492492492492492492492492492492
        492492492492492492492492492492492492492492492492492492492492492492492492
        492492492492492492492492492492492492492492492492492492492492492492492492
        492492492492492492492492492492492492492492492492492492492492492492492492
        4;
    BOOLEAN SAMPLEMASK[1634] = $000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000000000000
        0;
    BOOLEAN BSR[1634];
    BOOLEAN SAMPLE_DEVICE[1634];
    INTEGER CERTIFICATE_SIZE =928;
    BOOLEAN COMPONENTDIGEST[256];
    BOOLEAN COFC_NONCE[128] = $00000000000000000000000000000000;
    INTEGER COMPONENETSUPPORTSCERT =0;
    BOOLEAN AUXLO_REG[128];
    BOOLEAN AUXHI_REG[128];
    INTEGER DATASTARTINDEX =0;
    INTEGER DATAERASESTARTINDEX =75809536;
    INTEGER DATAENVMSIZE =0;
    INTEGER DATASIZE =4;
    INTEGER DATAERASESIZE =3;
    INTEGER NUMOFCOMPONENTS =7;
    BOOLEAN NUMOFBLOCKS[156] = $00001f0039440001f00007c0019f241ea40001f;
    INTEGER LABEL_SEPARATOR =0;
    BOOLEAN READ_SN_RESULT[129];
    BOOLEAN READ_FSN_RESULT[129];
    INTEGER DUMPDSN =1;
    INTEGER DUMPDEVCERTINFO =1;
    BOOLEAN DSN[128] = $00000000000000000000000000000000;
    INTEGER PERCENT_UPDATE;
    INTEGER DIFFERENCE;
    INTEGER UNIQUEEXITCODE =0;
    BOOLEAN SYSREG_TEMP[32];
    INTEGER ACTIONTYPE;
    INTEGER COMPTYPE;
    BOOLEAN DEVICE_CERTIFICATE[8192];
    BOOLEAN DEVICE_CERTIFICATE_READ = 0;
    BOOLEAN DEVICE_CERTIFICATE_VALIDATED = 0;
ENDDATA;

DATA CONSTBLOCK;
    INTEGER SELF=1;
    INTEGER SCULPTW=3;
    INTEGER BPWIN=4;
    INTEGER ACTEL_IHP=5;
    INTEGER FP3=2;
    INTEGER FP4=7;
    INTEGER FP5=8;
    INTEGER FP6=6;
    INTEGER EFP6=10;
    INTEGER SIL_EXPL=9;
    INTEGER ATE=14;
    INTEGER FP34=1;
    INTEGER FP40=2;
    INTEGER FP41=3;
    INTEGER FP42=4;
    INTEGER FP50=5;
    INTEGER FP51=6;
    INTEGER FP60=7;
    INTEGER FP61=8;
    INTEGER FP62=9;
    INTEGER FP84=11;
    INTEGER FP85=12;
    INTEGER FP86=13;
    INTEGER FP90=14;
    INTEGER FP91=15;
    INTEGER FP_10_LCP=16;
    INTEGER FP_11_BETA_SPA=17;
    INTEGER FP_11_BETA_SP1=18;
    INTEGER FP_11=19;
    INTEGER FP_11_1=20;
    INTEGER FP_11_2=21;
    INTEGER FP_11_3=22;
    INTEGER FP_11_4=23;
    INTEGER FP_11_5=24;
    INTEGER FP_11_6=25;
    INTEGER FP_11_7=26;
    INTEGER FP_11_8=27;
    INTEGER FP_G5_EAP4_SPA=28;
    INTEGER FP_PF_1_1_SP1=29;
    INTEGER FP_PF_2_0=30;
    INTEGER FP_PF_2_1=31;
    INTEGER FP_PF_2_2=32;
    INTEGER FP_PF_2_3=33;
    INTEGER FP_12_0=35;
    INTEGER FP_12_1=36;
    INTEGER FP_12_2=37;
    INTEGER FP_12_3=38;
    INTEGER FP_12_4=39;
    INTEGER FP_12_5=40;
    INTEGER FP_12_6=41;
    INTEGER FP_2021_1=42;
    INTEGER FP_2021_2=43;
    INTEGER FP_2021_3=44;
    INTEGER FP_2022_1=45;
    INTEGER FP_2022_2=46;
    INTEGER FP_2022_3=47;
    INTEGER FP_2023_1=48;
    INTEGER FP=1;
    INTEGER DIRECTC=2;
    INTEGER FPX=3;
    INTEGER NON_ACTEL=6;
    INTEGER PPD=1;
    INTEGER STAPL=2;
    INTEGER SVF=3;
    INTEGER PCF=4;
    INTEGER IEEE1532=5;
    INTEGER ACTION_NONE=0;
    INTEGER ACTION_PROG=1;
    INTEGER ACTION_VER=2;
    INTEGER ACTION_ERA=3;
    INTEGER ACTION_AUTH=4;
    INTEGER ACTION_DEV_INFO=5;
    INTEGER ACTION_VAL_KEYS=6;
    INTEGER ACTION_READ_DEV_CERT=7;
    INTEGER COMP_UNDEF=128;
    INTEGER COMP_BITS=0;
    INTEGER COMP_FPGA=1;
    INTEGER COMP_KEYS=2;
    INTEGER COMP_SNVM=3;
    INTEGER COMP_EOB=127;
ENDDATA;

PROCEDURE SET_PROGRAM_ACTIONTYPE USES GV,CONSTBLOCK;
    ACTIONTYPE = ACTION_PROG;
ENDPROC;

PROCEDURE SET_VERIFY_ACTIONTYPE USES GV,CONSTBLOCK;
    ACTIONTYPE = ACTION_VER;
ENDPROC;

PROCEDURE SET_ERASE_ACTIONTYPE USES GV,CONSTBLOCK;
    ACTIONTYPE = ACTION_ERA;
ENDPROC;

PROCEDURE SET_AUTHENTICATION_ACTIONTYPE USES GV,CONSTBLOCK;
    ACTIONTYPE = ACTION_AUTH;
ENDPROC;

PROCEDURE SET_DEVICE_INFO_ACTIONTYPE USES GV,CONSTBLOCK;
    ACTIONTYPE = ACTION_DEV_INFO;
ENDPROC;

PROCEDURE SET_VALIDATE_KEYS_ACTIONTYPE USES GV,CONSTBLOCK;
    ACTIONTYPE = ACTION_VAL_KEYS;
ENDPROC;

PROCEDURE SET_READ_DEV_CERT_ACTIONTYPE USES GV,CONSTBLOCK;
    ACTIONTYPE = ACTION_READ_DEV_CERT;
ENDPROC;

PROCEDURE EXPORT_CERTIFICATES USES GV;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE READ_DSN USES GV;
    PASS = 0;
    READ_SN_RESULT[128..0] = $000000000000000000000000000000000;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $f0;
    DRSCAN 129, READ_SN_RESULT[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 129, $000000000000000000000000000000000, CAPTURE READ_SN_RESULT[];
        IF ( ! (READ_SN_RESULT[128]==0) ) THEN GOTO READ_DSN_POLL;
        IPOLL = 0;
        PASS = 1;
        READ_DSN_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_DSN_DONE;
        IRSCAN 8, $f0;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_DSN_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO READ_DSN_COMPLETE;
    PRINT "Failed to read DSN.";
    STATUS = -24;
    UNIQUEEXITCODE = 32769;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    READ_DSN_COMPLETE:
    DSN[127..0] = READ_SN_RESULT[127..0];
    IF ( ! (DUMPDSN==1) ) THEN GOTO DONT_DUMP_DSN;
    PRINT "===================================================================================";
    EXPORT "DSN", READ_SN_RESULT[127..0];
    PRINT "===================================================================================";
    DONT_DUMP_DSN:
    DUMPDSN = 1;
    READ_FSN_RESULT[] = READ_SN_RESULT[];
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE POLL_DEVICE_READY_DURING_EXIT USES GV;
    PASS = 0;
    INTEGER ILOOP_0;
    FOR ILOOP_0 = 10000 -1 TO 0 STEP -1;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $0d;
        WAIT IDLE, 1 CYCLES;
        WAIT IDLE, 10 USEC;
        DRSCAN 8, $00,COMPARE $00,$80,PASS;
        IF PASS THEN ILOOP_0 = 0;
        WAIT IDLE, 1000 USEC;
    NEXT ILOOP_0;
    IF ( ! (PASS==0) ) THEN GOTO DEVICE_READY2;
    PRINT "Instruction timed out. Device is busy.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    DEVICE_READY2:
    WAIT RESET, 300000 USEC;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_EXIT USES GV,CONSTBLOCK,EXPORT_CERTIFICATES,READ_DSN,POLL_DEVICE_READY_DURING_EXIT;
    IF ( ! (BPGMMODE==1) ) THEN GOTO SKIP_ISC_DISABLE;
    BOOLEAN ISC_DISABLE_RESULT[32];
    CALL READ_DSN;
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0c;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 32, $00000000, CAPTURE ISC_DISABLE_RESULT[31..0];
        IF ( ! (ISC_DISABLE_RESULT[31]==0) ) THEN GOTO ISC_DISABLE_POLL;
        IPOLL = 0;
        PASS = 1;
        ISC_DISABLE_POLL:
        IF ( ! (PASS==0) ) THEN GOTO ISC_DISABLE_DONE;
        IRSCAN 8, $0c;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        ISC_DISABLE_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO ISC_DISABLE_PASS;
    PRINT "Instruction timed out while disabling programming mode.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    ISC_DISABLE_PASS:
    LABEL_SEPARATOR = 0;
    SKIP_ISC_DISABLE:
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $09;
    WAIT IDLE, 1 CYCLES;
    WAIT IDLE, 1000 USEC;
    WAIT RESET, 5 CYCLES;
    IF ( ! ( (BPGMMODE==1)&&(JTAG_DIS==0)) ) THEN GOTO SKIP_POLL_DELAY;
    CALL POLL_DEVICE_READY_DURING_EXIT;
    SKIP_POLL_DELAY:
    IF ( ! (ACTIONTYPE!=ACTION_NONE) ) THEN GOTO DONT_EXPORT_COFC;
    CALL EXPORT_CERTIFICATES;
    DONT_EXPORT_COFC:
    EXIT STATUS;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE LOAD_AUXLO USES GV,DO_EXIT;
    BOOLEAN AUXLO_RESULT[128];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $e9;
    DRSCAN 128, AUXLO_REG[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE AUXLO_RESULT[127..0];
        IF ( ! (AUXLO_RESULT[127]==0) ) THEN GOTO AUXLO_POLL;
        IPOLL = 0;
        PASS = 1;
        AUXLO_POLL:
        IF ( ! (PASS==0) ) THEN GOTO AUXLO_DONE;
        IRSCAN 8, $e9;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        AUXLO_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO AUXLO_PASS;
    PRINT "Instruction timed out while loading auxlo.";
    EXPORT "auxlo_result", AUXLO_RESULT[127..0];
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    AUXLO_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE LOAD_AUXHI USES GV,DO_EXIT;
    BOOLEAN AUXHI_RESULT[128];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $ea;
    DRSCAN 128, AUXHI_REG[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE AUXHI_RESULT[127..0];
        IF ( ! (AUXHI_RESULT[127]==0) ) THEN GOTO AUXHI_POLL;
        IPOLL = 0;
        PASS = 1;
        AUXHI_POLL:
        IF ( ! (PASS==0) ) THEN GOTO AUXHI_DONE;
        IRSCAN 8, $ea;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        AUXHI_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO AUXHI_PASS;
    PRINT "Instruction timed out while loading auxhi.";
    EXPORT "auxhi_result", AUXHI_RESULT[127..0];
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    AUXHI_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE POLL_DEVICE_READY USES GV,DO_EXIT;
    PASS = 0;
    INTEGER ILOOP_1;
    FOR ILOOP_1 = 10000 -1 TO 0 STEP -1;
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $0d;
        WAIT IDLE, 1 CYCLES;
        WAIT IDLE, 10 USEC;
        DRSCAN 8, $00,COMPARE $00,$80,PASS;
        IF PASS THEN ILOOP_1 = 0;
    NEXT ILOOP_1;
    IF ( ! (PASS==0) ) THEN GOTO DEVICE_READY;
    PRINT "Instruction timed out. Device is busy.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    DEVICE_READY:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE READ_SHARED_BUFFER USES GV,DO_EXIT;
    INTEGER IBLOCK =0;
    BOOLEAN BLOCKBUFFER[129];
    FOR IBLOCK = 0 TO (IBLOCKS-1) STEP 1;
        PASS = 0;
        BOOLEAN SHARED_BUFFER_RESULT[129];
        BLOCKBUFFER[8..1] = BOOL(IBLOCK);
        IRSTOP IRPAUSE;
        DRSTOP DRPAUSE;
        IRSCAN 8, $f2;
        DRSCAN 129, BLOCKBUFFER[];
        WAIT IDLE, 3 CYCLES;
        WAIT 10 USEC, DRPAUSE;
        FOR IPOLL = 100000 TO 0 STEP -1;
            DRSCAN 129, $000000000000000000000000000000000, CAPTURE SHARED_BUFFER_RESULT[];
            IF ( ! (SHARED_BUFFER_RESULT[128]==0) ) THEN GOTO READ_BUFFER_POLL;
            IPOLL = 0;
            PASS = 1;
            READ_BUFFER_POLL:
            IF ( ! (PASS==0) ) THEN GOTO READ_BUFFER_DONE;
            IRSCAN 8, $f2;
            WAIT IRPAUSE, 10 USEC, IRPAUSE;
            READ_BUFFER_DONE:
            LABEL_SEPARATOR = 0;
        NEXT IPOLL;
        IF ( ! (PASS==0) ) THEN GOTO READ_BUFFER_PASS;
        PRINT "Instruction timed out while reading design information.";
        STATUS = -32;
        UNIQUEEXITCODE = 32818;
        BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
        EXPORT "ERROR_CODE", BUFF32[15..0];
        CALL DO_EXIT;
        READ_BUFFER_PASS:
        SHARED_BUFFER[((128*IBLOCK)+127)..(128*IBLOCK)] = SHARED_BUFFER_RESULT[127..0];
    NEXT IBLOCK;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_QUERY_SECURITY USES GV,DO_EXIT,READ_SHARED_BUFFER;
    BOOLEAN QUERY_SECURITY_RESULT[16];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $b8;
    DRSCAN 16, $0000;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 16, $0000, CAPTURE QUERY_SECURITY_RESULT[];
        IF ( ! (QUERY_SECURITY_RESULT[15]==0) ) THEN GOTO QUERY_SECURITY_POLL;
        IPOLL = 0;
        PASS = 1;
        QUERY_SECURITY_POLL:
        IF ( ! (PASS==0) ) THEN GOTO QUERY_SECURITY_DONE;
        IRSCAN 8, $b8;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        QUERY_SECURITY_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO QUERY_SECURITY_PASS;
    PRINT "Instruction timed out while querying security information.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    QUERY_SECURITY_PASS:
    IBLOCKS = 1;
    CALL READ_SHARED_BUFFER;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_DUMP_SECURITY USES GV,DO_QUERY_SECURITY;
    CALL DO_QUERY_SECURITY;
    PRINT "--- Security locks and configuration settings ---";
    EXPORT "QUERY_SECURITY", SHARED_BUFFER[71..0];
    IF ( ! (SHARED_BUFFER[60]==1) ) THEN GOTO UP_DEBUG_UL_DEBUG_OFF;
    PRINT "SmartDebug user debug access and active probes are permanently disabled.";
    PRINT "SmartDebug sNVM debug is permanently disabled.";
    PRINT "SmartDebug Live probes are permanently disabled.";
    PRINT "Reading of temperature and voltage via JTAG/SPI Slave is permanently disabled.";
    UP_DEBUG_UL_DEBUG_OFF:
    IF ( ! (SHARED_BUFFER[60]==0) ) THEN GOTO UP_DEBUG_UL_DEBUG_ON;
    IF ( ! (SHARED_BUFFER[0]==1) ) THEN GOTO UL_DEBUG;
    PRINT "SmartDebug user debug access and active probes are disabled.";
    UL_DEBUG:
    IF ( ! (SHARED_BUFFER[1]==1) ) THEN GOTO UL_SNVM_DEBUG;
    PRINT "SmartDebug sNVM debug is disabled.";
    UL_SNVM_DEBUG:
    IF ( ! (SHARED_BUFFER[2]==1) ) THEN GOTO UL_LIVEPROBE;
    PRINT "SmartDebug Live probes are disabled.";
    UL_LIVEPROBE:
    IF ( ! (SHARED_BUFFER[3]==1) ) THEN GOTO UL_UJTAG;
    PRINT "User JTAG interface is disabled";
    UL_UJTAG:
    IF ( ! (SHARED_BUFFER[4]==1) ) THEN GOTO UL_JTAG_BS;
    PRINT "JTAG boundary scan is disabled.";
    UL_JTAG_BS:
    IF ( ! (SHARED_BUFFER[5]==1) ) THEN GOTO UL_TVS_MONITOR;
    PRINT "Reading of temperature and voltage via JTAG/SPI Slave is disabled.";
    UL_TVS_MONITOR:
    LABEL_SEPARATOR = 0;
    UP_DEBUG_UL_DEBUG_ON:
    IF ( ! (SHARED_BUFFER[7]==1) ) THEN GOTO UL_JTAG;
    JTAG_DIS = 1;
    PRINT "JTAG is disabled.";
    UL_JTAG:
    IF ( ! (SHARED_BUFFER[8]==1) ) THEN GOTO UL_PLAIN_TEXT;
    PRINT "Plaintext passcode unlock is disabled.";
    UL_PLAIN_TEXT:
    IF ( ! (SHARED_BUFFER[61]==1) ) THEN GOTO UP_FABRIC_OFF;
    PRINT "Fabric erase/write is permanently disabled.";
    UP_FABRIC_OFF:
    IF ( ! (SHARED_BUFFER[61]==0) ) THEN GOTO UP_FABRIC_ON;
    IF ( ! (SHARED_BUFFER[9]==1) ) THEN GOTO UL_FAB_PROTECT;
    PRINT "Fabric erase/write is disabled.";
    UL_FAB_PROTECT:
    LABEL_SEPARATOR = 0;
    UP_FABRIC_ON:
    IF ( ! (SHARED_BUFFER[10]==1) ) THEN GOTO UL_EXT_DIGEST;
    PRINT "External digest check via JTAG/SPI Slave is disabled.";
    UL_EXT_DIGEST:
    IF ( ! (SHARED_BUFFER[11]==1) ) THEN GOTO UL_BACKLEVEL;
    PRINT "Back level protection is enabled.";
    UL_BACKLEVEL:
    IF ( ! (SHARED_BUFFER[59]==1) ) THEN GOTO UP_FACTORY_OFF;
    PRINT "Microsemi factory test access is permanently disabled.";
    UP_FACTORY_OFF:
    IF ( ! (SHARED_BUFFER[59]==0) ) THEN GOTO UP_FACTORY_ON;
    IF ( ! (SHARED_BUFFER[12]==1) ) THEN GOTO UL_FACT_UNLOCK;
    PRINT "Microsemi factory test mode is disabled.";
    UL_FACT_UNLOCK:
    IF ( ! (SHARED_BUFFER[12]==0) ) THEN GOTO UL_FACT_UNLOCK_ON;
    PRINT "Microsemi factory test mode access is allowed.";
    UL_FACT_UNLOCK_ON:
    LABEL_SEPARATOR = 0;
    UP_FACTORY_ON:
    IF ( ! (SHARED_BUFFER[13]==1) ) THEN GOTO UL_IAP;
    PRINT "Auto Programming and IAP Services are disabled.";
    UL_IAP:
    IF ( ! (SHARED_BUFFER[14]==1) ) THEN GOTO UL_EXT_ZEROIZE;
    PRINT "External zeroizations via JTAG/SPI Slave is disabled.";
    UL_EXT_ZEROIZE:
    IF ( ! (SHARED_BUFFER[15]==1) ) THEN GOTO UL_SPI_SLAVE;
    PRINT "SPI Slave port is disabled.";
    UL_SPI_SLAVE:
    IF ( ! (SHARED_BUFFER[17]==1) ) THEN GOTO UL_BS_AUTHENTICATE;
    PRINT "Authenticate programming action for JTAG/SPI Slave is disabled.";
    UL_BS_AUTHENTICATE:
    IF ( ! (SHARED_BUFFER[18]==1) ) THEN GOTO UL_BS_PROGRAM;
    PRINT "Program action for JTAG/SPI Slave is disabled.";
    UL_BS_PROGRAM:
    IF ( ! (SHARED_BUFFER[19]==1) ) THEN GOTO UL_BS_VERIFY;
    PRINT "Verify action for JTAG/SPI Slave is disabled.";
    UL_BS_VERIFY:
    IF ( ! (SHARED_BUFFER[22]==1) ) THEN GOTO UL_BITS_KEYMD2;
    PRINT "Bitstream Default encryption key (KLK) is disabled.";
    UL_BITS_KEYMD2:
    IF ( ! (SHARED_BUFFER[23]==1) ) THEN GOTO UL_BITS_KEYMD3;
    PRINT "Bitstream User Encryption Key 1 is disabled.";
    UL_BITS_KEYMD3:
    IF ( ! (SHARED_BUFFER[24]==1) ) THEN GOTO UL_BITS_KEYMD4;
    PRINT "Bitstream User Encryption Key 2 is disabled.";
    UL_BITS_KEYMD4:
    IF ( ! (SHARED_BUFFER[26]==1) ) THEN GOTO UL_BITS_KEYMD6;
    PRINT "Bitstream AUTH_CODE key mode is disabled.";
    UL_BITS_KEYMD6:
    IF ( ! (SHARED_BUFFER[38]==1) ) THEN GOTO UL_KEYMD2;
    PRINT "Default encryption key (KLK) is disabled.";
    UL_KEYMD2:
    IF ( ! (SHARED_BUFFER[39]==1) ) THEN GOTO UL_KEYMD3;
    PRINT "User Encryption Key 1 is disabled.";
    UL_KEYMD3:
    IF ( ! (SHARED_BUFFER[40]==1) ) THEN GOTO UL_KEYMD4;
    PRINT "User Encryption Key 2 is disabled.";
    UL_KEYMD4:
    IF ( ! (SHARED_BUFFER[42]==1) ) THEN GOTO UL_KEYMD6;
    PRINT "AUTH_CODE key mode is disabled.";
    UL_KEYMD6:
    IF ( ! (SHARED_BUFFER[52]==1) ) THEN GOTO UL_SNVM_PROTECT;
    PRINT "sNVM write is disabled.";
    UL_SNVM_PROTECT:
    IF ( ! (SHARED_BUFFER[53]==1) ) THEN GOTO UL_EXT_CHALLENGE;
    PRINT "PUF emulation via JTAG/SPI Slave is disabled.";
    UL_EXT_CHALLENGE:
    IF ( ! (SHARED_BUFFER[62]==1) ) THEN GOTO UP_UPK1_OFF;
    PRINT "FlashLock/UPK1 unlocking is permanently disabled.";
    PRINT "User lock segment is permanently locked.";
    PRINT "User Key Set 1 is permanently locked.";
    UP_UPK1_OFF:
    IF ( ! (SHARED_BUFFER[62]==0) ) THEN GOTO UP_UPK1_ON;
    IF ( ! (SHARED_BUFFER[57]==1) ) THEN GOTO UL_USER_KEY;
    PRINT "User Key Set 1 is locked. FlashLock/UPK1 is required to make changes.";
    UL_USER_KEY:
    IF ( ! (SHARED_BUFFER[16]==1) ) THEN GOTO UL_USL;
    PRINT "User lock segment is locked. FlashLock/UPK1 is required to make changes to security.";
    UL_USL:
    LABEL_SEPARATOR = 0;
    UP_UPK1_ON:
    IF ( ! (SHARED_BUFFER[63]==1) ) THEN GOTO UP_UPK2_OFF;
    PRINT "FlashLock/UPK2 unlocking is permanently disabled.";
    UP_UPK2_OFF:
    IF ( ! (SHARED_BUFFER[63]==0) ) THEN GOTO UP_UPK2_ON;
    IF ( ! (SHARED_BUFFER[58]==1) ) THEN GOTO UL_USER_KEY2;
    PRINT "User Key Set 2 is locked. FlashLock/UPK2 is required to make changes.";
    UL_USER_KEY2:
    LABEL_SEPARATOR = 0;
    UP_UPK2_ON:
    IF ( ! (SHARED_BUFFER[64]==1) ) THEN GOTO UP_DPK;
    PRINT "FlashLock/DPK unlocking is permanently disabled.";
    UP_DPK:
    IF ( ! (SHARED_BUFFER[65]==1) ) THEN GOTO UP_PROTECT;
    PRINT "Permanent lock segment is permanently locked.";
    UP_PROTECT:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE LOAD_KEYLO USES GV,DO_EXIT;
    BOOLEAN KEYLO_RESULT[128];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $eb;
    DRSCAN 128, KEYLO_REG[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE KEYLO_RESULT[127..0];
        IF ( ! (KEYLO_RESULT[127]==0) ) THEN GOTO KEYLO_POLL;
        IPOLL = 0;
        PASS = 1;
        KEYLO_POLL:
        IF ( ! (PASS==0) ) THEN GOTO KEYLO_DONE;
        IRSCAN 8, $eb;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        KEYLO_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO KEYLO_PASS;
    PRINT "Instruction timed out while loading keylo.";
    EXPORT "keylo_result", KEYLO_RESULT[127..0];
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    KEYLO_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE LOAD_KEYHI USES GV,DO_EXIT;
    BOOLEAN KEYHI_RESULT[128];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $ec;
    DRSCAN 128, KEYHI_REG[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE KEYHI_RESULT[127..0];
        IF ( ! (KEYHI_RESULT[127]==0) ) THEN GOTO KEYHI_POLL;
        IPOLL = 0;
        PASS = 1;
        KEYHI_POLL:
        IF ( ! (PASS==0) ) THEN GOTO KEYHI_DONE;
        IRSCAN 8, $ec;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        KEYHI_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO KEYHI_PASS;
    PRINT "Instruction timed out while loading keyhi.";
    EXPORT "keyhi_result", KEYHI_RESULT[127..0];
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    KEYHI_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_ZEROIZATION_RESULT USES GV,DO_EXIT,READ_SHARED_BUFFER;
    BOOLEAN READ_ZEROIZE_RESULT[128];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $e2;
    DRSCAN 128, READ_ZEROIZE_RESULT[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE READ_ZEROIZE_RESULT[127..0];
        IF ( ! (READ_ZEROIZE_RESULT[127]==0) ) THEN GOTO READ_ZEROIZE_POLL;
        IPOLL = 0;
        PASS = 1;
        READ_ZEROIZE_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_ZEROIZE_RESULT_DONE;
        IRSCAN 8, $e2;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_ZEROIZE_RESULT_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO READ_ZEROIZE_RESULT_PASS;
    PRINT "Instruction timed out while loading read zeroization instruction.";
    EXPORT "read_zeroize_result", READ_ZEROIZE_RESULT[127..0];
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_ZEROIZE_RESULT_PASS:
    IF ( ! ( (PASS==1)&&( (READ_ZEROIZE_RESULT[0]==1)||(READ_ZEROIZE_RESULT[1]==1))) ) THEN GOTO READ_ZEROIZE_SUCCESSFUL;
    PRINT "Failed to read zeroization certificate.";
    EXPORT "read_zeroize_result", READ_ZEROIZE_RESULT[];
    STATUS = -42;
    UNIQUEEXITCODE = 32854;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_ZEROIZE_SUCCESSFUL:
    IBLOCKS = 9;
    CALL READ_SHARED_BUFFER;
    EXPORT "FETCH_ZEROIZATION_RESULT", SHARED_BUFFER[1047..0];
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_ZEROIZE USES GV,DO_EXIT,DO_READ_ZEROIZATION_RESULT;
    BOOLEAN ZEROIZE_RESULT[128];
    PASS = 0;
    ZEROIZE_RESULT[127..8] = $a831064500195d7be50ac3253b16b6;
    ZEROIZE_RESULT[1..0] = ZMODE[];
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $e6;
    DRSCAN 128, ZEROIZE_RESULT[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 10000000 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE ZEROIZE_RESULT[127..0];
        IF ( ! (ZEROIZE_RESULT[127]==0) ) THEN GOTO ZEROIZE_POLL;
        IPOLL = 0;
        PASS = 1;
        ZEROIZE_POLL:
        IF ( ! (PASS==0) ) THEN GOTO ZEROIZE_DONE;
        IRSCAN 8, $e6;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        ZEROIZE_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO ZEROIZE_PASS;
    PRINT "Instruction timed out while loading zeroize instruction.";
    EXPORT "zeroize_result", ZEROIZE_RESULT[127..0];
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    ZEROIZE_PASS:
    IF ( ! ( (PASS==1)&&(ZEROIZE_RESULT[0]==1)) ) THEN GOTO ZEROIZE_SUCCESSFUL;
    PRINT "Failed to zeroize the device.";
    EXPORT "zeroize_result", ZEROIZE_RESULT[];
    STATUS = -40;
    UNIQUEEXITCODE = 32849;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    ZEROIZE_SUCCESSFUL:
    CALL DO_READ_ZEROIZATION_RESULT;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_UNLOCK_KEYS USES GV,DO_QUERY_SECURITY;
    CALL DO_QUERY_SECURITY;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_ZEROIZE_LIKE_NEW USES GV,DO_ZEROIZE,DO_UNLOCK_KEYS;
    CALL DO_UNLOCK_KEYS;
    PRINT "Zeroizing the device like new...";
    ZMODE[1..0] = $1;
    CALL DO_ZEROIZE;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_TVS_MONITOR USES GV,DO_EXIT;
    BOOLEAN TVS_MONITOR_RESULT[128];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $e3;
    DRSCAN 128, $00000000000000000000000000000000;
    WAIT IDLE, 3 CYCLES;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE TVS_MONITOR_RESULT[127..0];
        IF ( ! (TVS_MONITOR_RESULT[127]==0) ) THEN GOTO TVS_MONITOR_POLL;
        IPOLL = 0;
        PASS = 1;
        TVS_MONITOR_POLL:
        IF ( ! (PASS==0) ) THEN GOTO TVS_MONITOR_DONE;
        IRSCAN 8, $e3;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        TVS_MONITOR_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO TVS_MONITOR_PASSED;
    PRINT "Instruction timed out while reading tvs monitor.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    TVS_MONITOR_PASSED:
    IF ( ! (TVS_MONITOR_RESULT[16]==1) ) THEN GOTO Label_0;
    EXPORT "TVS Channel 0 - 1 V voltage supply", TVS_MONITOR_RESULT[15..0];
    Label_0:
    IF ( ! (TVS_MONITOR_RESULT[48]==1) ) THEN GOTO Label_1;
    EXPORT "TVS Channel 1 - 1.8 V voltage supply", TVS_MONITOR_RESULT[47..32];
    Label_1:
    IF ( ! (TVS_MONITOR_RESULT[80]==1) ) THEN GOTO Label_2;
    EXPORT "TVS Channel 2 - 2.5 V voltage supply", TVS_MONITOR_RESULT[79..64];
    Label_2:
    IF ( ! (TVS_MONITOR_RESULT[112]==1) ) THEN GOTO Label_3;
    EXPORT "TVS Channel 3 - Die temperature", TVS_MONITOR_RESULT[111..96];
    Label_3:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE PRINT_IDCODE USES GV;
    EXPORT "IDCODE", ID[];
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE SET_READ_IDCODE USES GV;
    BREADIDCODE = 1;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE VERIFY_IDCODE USES GV,PARAMETERS,DO_EXIT,POLL_DEVICE_READY,PRINT_IDCODE;
    FREQUENCY (FREQ*1000000);
    BUFF32[15..0] = BOOL(ALGO_VERSION);
    EXPORT "Algo_version", BUFF32[15..0];
    WAIT RESET, 5 CYCLES;
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0f;
    DRSCAN 32, $00000000;
    WAIT IDLE, 1 CYCLES;
    DRSCAN 32, $00000000, CAPTURE ID[],COMPARE IDCODEVALUE[],IDMASK[],PASS;
    CALL PRINT_IDCODE;
    IDREV = INT(ID[31..28]);
    IF ( ! (PASS==0) ) THEN GOTO IDOK;
    STATUS = 6;
    UNIQUEEXITCODE = 32772;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    PRINT "Failed to verify IDCODE";
    CALL DO_EXIT;
    IDOK:
    IF ( ! (PASS==1) ) THEN GOTO IDNOTOK;
    IF ( ! (IDREV<5) ) THEN GOTO NOT_PROD;
    PRINT "Failed to verify IDCODE";
    PRINT "MPF300(T|TS|TL|TLS) programming file is not compatible with MPF300(XT|T_ES|TS_ES) devices.";
    PRINT "You must use a programming file for MPF300(XT|T_ES|TS_ES) device.";
    STATUS = 6;
    UNIQUEEXITCODE = 32858;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    NOT_PROD:
    LABEL_SEPARATOR = 0;
    IDNOTOK:
    IF ( ! (BREADIDCODE==0) ) THEN GOTO DOING_READ_IDCODE;
    CALL POLL_DEVICE_READY;
    DOING_READ_IDCODE:
    BREADIDCODE = 0;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE GET_DATA_STATUS USES GV,DO_EXIT;
    INTEGER IPOLLDATA =0;
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $d8;
    DRSCAN 64, $0000000000000000;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLLDATA = 100000 TO 0 STEP -1;
        DRSCAN 64, $0000000000000000, CAPTURE DATA_STATUS_RESULT[63..0];
        IF ( ! (DATA_STATUS_RESULT[63]==0) ) THEN GOTO DATA_STATUS_POLL;
        IPOLLDATA = 0;
        PASS = 1;
        DATA_STATUS_POLL:
        IF ( ! (PASS==0) ) THEN GOTO DATA_STATUS_READ;
        IRSCAN 8, $d8;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        DATA_STATUS_READ:
        LABEL_SEPARATOR = 0;
    NEXT IPOLLDATA;
    IF ( ! (PASS==0) ) THEN GOTO GET_DATA_NOT_TIMED_OUT;
    PRINT "Instruction timed out while reading datablock status.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    GET_DATA_NOT_TIMED_OUT:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE READ_CERTIFICATE USES GV,READ_SHARED_BUFFER;
    IBLOCKS = (CERTIFICATE_SIZE/128);
    IF ( ! ((CERTIFICATE_SIZE%128)!=0) ) THEN GOTO NO_INCOM_BLOCK;
    IBLOCKS = (IBLOCKS+1);
    NO_INCOM_BLOCK:
    CALL READ_SHARED_BUFFER;
    COMPONENTDIGEST[255..0] = SHARED_BUFFER[415..160];
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_DEBUG_INFO USES GV,DO_EXIT,READ_SHARED_BUFFER;
    PASS = 0;
    BOOLEAN READ_DEBUG_INFO_RESULT[128];
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $e7;
    DRSCAN 128, $00000000000000000000000000000000;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 128, $00000000000000000000000000000000, CAPTURE READ_DEBUG_INFO_RESULT[];
        IF ( ! (READ_DEBUG_INFO_RESULT[127]==0) ) THEN GOTO READ_DEBUG_INFO_POLL;
        IPOLL = 0;
        PASS = 1;
        READ_DEBUG_INFO_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_DEBUG_INFO_DONE;
        IRSCAN 8, $e7;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_DEBUG_INFO_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO READ_DEBUG_INFO_PASS;
    PRINT "Instruction timed out while reading debug information.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_DEBUG_INFO_PASS:
    IBLOCKS = 6;
    CALL READ_SHARED_BUFFER;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_DIGESTS USES GV,DO_EXIT,READ_SHARED_BUFFER;
    BOOLEAN READ_DIGESTS_RESULT[8];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a3;
    DRSCAN 8, $00;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 8, $00, CAPTURE READ_DIGESTS_RESULT[];
        IF ( ! (READ_DIGESTS_RESULT[7]==0) ) THEN GOTO READ_DIGESTS_POLL;
        IPOLL = 0;
        PASS = 1;
        READ_DIGESTS_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_DIGESTS_DONE;
        IRSCAN 8, $a3;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_DIGESTS_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO READ_DIGESTS_PASS;
    PRINT "Instruction timed out while reading device digests.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_DIGESTS_PASS:
    IBLOCKS = 26;
    CALL READ_SHARED_BUFFER;
    IF ( ! (ONLY_CHECK_UKDIGEST0==1) ) THEN GOTO Label_5;
    FOR I = 1279 TO 1024 STEP -1;
        IF ( ! (SHARED_BUFFER[I]!=0) ) THEN GOTO Label_4;
        SMK_INITIALIZED = 1;
        Label_4:
        LABEL_SEPARATOR = 0;
    NEXT I;
    Label_5:
    IF ( ! (ONLY_CHECK_UKDIGEST0==0) ) THEN GOTO Label_6;
    PRINT "Reading digests for all the segments...";
    EXPORT "CHECK FABRIC digest", SHARED_BUFFER[255..0];
    EXPORT "CC digest", SHARED_BUFFER[511..256];
    EXPORT "SNVM digest", SHARED_BUFFER[767..512];
    EXPORT "UL digest", SHARED_BUFFER[1023..768];
    EXPORT "UKDIGEST0 digest", SHARED_BUFFER[1279..1024];
    EXPORT "UKDIGEST1 digest", SHARED_BUFFER[1535..1280];
    EXPORT "UKDIGEST2 digest", SHARED_BUFFER[1791..1536];
    EXPORT "UKDIGEST3 digest", SHARED_BUFFER[2047..1792];
    EXPORT "UKDIGEST4 digest", SHARED_BUFFER[2303..2048];
    EXPORT "UKDIGEST5 digest", SHARED_BUFFER[2559..2304];
    EXPORT "UKDIGEST6 digest", SHARED_BUFFER[2815..2560];
    EXPORT "UPERM digest", SHARED_BUFFER[3071..2816];
    EXPORT "SYS digest", SHARED_BUFFER[3327..3072];
    PRINT "Please refer to PolarFire/PolarFire SoC Security User Guide for more details about different digests.";
    Label_6:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE SET_MODE USES GV,DO_EXIT,LOAD_AUXLO;
    AUXLO_REG[127..0] = COFC_NONCE[127..0];
    CALL LOAD_AUXLO;
    BOOLEAN DATA_INIT_RESULT[8];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $ae;
    DRSCAN 8, PGMMODE[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 8, $00, CAPTURE DATA_INIT_RESULT[7..0];
        IF ( ! (DATA_INIT_RESULT[7]==0) ) THEN GOTO DATA_INIT_POLL;
        IPOLL = 0;
        PASS = 1;
        DATA_INIT_POLL:
        IF ( ! (PASS==0) ) THEN GOTO DATA_INIT_DONE;
        IRSCAN 8, $ae;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        DATA_INIT_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO DATA_INIT_PASSED;
    PRINT "Instruction timed out while setting programming mode.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    DATA_INIT_PASSED:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_CERTIFICATE USES GV,DO_EXIT,READ_SHARED_BUFFER;
    PASS = 0;
    BOOLEAN READ_CERT_RESULT[8];
    DEVICE_CERTIFICATE_READ = 0;
    DEVICE_CERTIFICATE_VALIDATED = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a2;
    WAIT IDLE, 1 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 27777 TO 0 STEP -1;
        DRSCAN 8, $00, CAPTURE READ_CERT_RESULT[7..0];
        IF ( ! (READ_CERT_RESULT[7]==0) ) THEN GOTO READ_CERT_POLL;
        IPOLL = 0;
        PASS = 1;
        READ_CERT_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_CERT_DONE;
        IRSCAN 8, $a2;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_CERT_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO READ_CERT_PASSED;
    PRINT "Instruction timed out while reading device certificate, device is busy.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_CERT_PASSED:
    IF ( ! (READ_CERT_RESULT[1]==0) ) THEN GOTO READ_CERT_INVALID;
    IBLOCKS = 64;
    CALL READ_SHARED_BUFFER;
    DEVICE_CERTIFICATE[8191..0] = SHARED_BUFFER[8191..0];
    DEVICE_CERTIFICATE_READ = 1;
    DEVICE_CERTIFICATE_VALIDATED = READ_CERT_RESULT[0];
    IF ( ! (DUMPDEVCERTINFO==1) ) THEN GOTO Label_9;
    PRINT "Family: ",CHR$(INT(SHARED_BUFFER[1447..1440])),CHR$(INT(SHARED_BUFFER[1455..1448]))
        ,CHR$(INT(SHARED_BUFFER[1463..1456])),CHR$(INT(SHARED_BUFFER[1471..1464]))
        ,CHR$(INT(SHARED_BUFFER[1479..1472])),CHR$(INT(SHARED_BUFFER[1487..1480]))
        ,CHR$(INT(SHARED_BUFFER[1495..1488])),CHR$(INT(SHARED_BUFFER[1503..1496]))
        ,CHR$(INT(SHARED_BUFFER[1511..1504])),CHR$(INT(SHARED_BUFFER[1519..1512]))
        ,CHR$(INT(SHARED_BUFFER[1527..1520])),CHR$(INT(SHARED_BUFFER[1535..1528]));
    PRINT "Product: ",CHR$(INT(SHARED_BUFFER[1615..1608])),CHR$(INT(SHARED_BUFFER[1623..1616]))
        ,CHR$(INT(SHARED_BUFFER[1631..1624])),CHR$(INT(SHARED_BUFFER[1639..1632]))
        ,CHR$(INT(SHARED_BUFFER[1647..1640])),CHR$(INT(SHARED_BUFFER[1655..1648]))
        ,CHR$(INT(SHARED_BUFFER[1663..1656])),CHR$(INT(SHARED_BUFFER[1671..1664]))
        ,CHR$(INT(SHARED_BUFFER[1679..1672])),CHR$(INT(SHARED_BUFFER[1687..1680]))
        ,CHR$(INT(SHARED_BUFFER[1695..1688])),CHR$(INT(SHARED_BUFFER[1703..1696]))
        ,CHR$(INT(SHARED_BUFFER[1711..1704])),CHR$(INT(SHARED_BUFFER[1719..1712]))
        ,CHR$(INT(SHARED_BUFFER[1727..1720])),CHR$(INT(SHARED_BUFFER[1735..1728]))
        ,CHR$(INT(SHARED_BUFFER[1743..1736])),CHR$(INT(SHARED_BUFFER[1751..1744]))
        ,CHR$(INT(SHARED_BUFFER[1759..1752])),CHR$(INT(SHARED_BUFFER[1767..1760]))
        ,CHR$(INT(SHARED_BUFFER[1775..1768])),CHR$(INT(SHARED_BUFFER[1783..1776]))
        ,CHR$(INT(SHARED_BUFFER[1791..1784])),CHR$(INT(SHARED_BUFFER[1799..1792]))
        ,CHR$(INT(SHARED_BUFFER[1807..1800])),CHR$(INT(SHARED_BUFFER[1815..1808]))
        ,CHR$(INT(SHARED_BUFFER[1823..1816])),CHR$(INT(SHARED_BUFFER[1831..1824]))
        ,CHR$(INT(SHARED_BUFFER[1839..1832])),CHR$(INT(SHARED_BUFFER[1847..1840]))
        ,CHR$(INT(SHARED_BUFFER[1855..1848])),CHR$(INT(SHARED_BUFFER[1863..1856]))
        ,CHR$(INT(SHARED_BUFFER[1871..1864]));
    Label_9:
    LABEL_SEPARATOR = 0;
    READ_CERT_INVALID:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_DISPLAY_CERTIFICATE USES GV,CONSTBLOCK,DO_EXIT;
    PASS = 0;
    IF ( ! ( (DEVICE_CERTIFICATE_READ==1)&&(DEVICE_CERTIFICATE_VALIDATED==0)) ) THEN GOTO READ_CERT_SIGNATURE_CHECK_ERROR;
    PRINT "Device certificate could not be validated due to internal error.";
    STATUS = -36;
    UNIQUEEXITCODE = 33002;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_CERT_SIGNATURE_CHECK_ERROR:
    IF ( ! ( (DEVICE_CERTIFICATE_READ==1)&&(DEVICE_CERTIFICATE_VALIDATED==1)) ) THEN GOTO READ_CERT_SIGNATURE_OK;
    PRINT "Device certificate signature has been verified.";
    IF ( ! (ACTIONTYPE==ACTION_READ_DEV_CERT) ) THEN GOTO DONT_DUMP_ENTIRE_CERT;
    BOOLEAN DEV_CERT_REV_BYTEORDER[8192];
    FOR I = 0 TO 8183 STEP 8;
        DEV_CERT_REV_BYTEORDER[(I+7)..I] = SHARED_BUFFER[(8191-I)..(8184-I)];
    NEXT I;
    EXPORT "DEVICE_CERTIFICATE(LSB->MSB)", DEV_CERT_REV_BYTEORDER[8191..0];
    DONT_DUMP_ENTIRE_CERT:
    LABEL_SEPARATOR = 0;
    READ_CERT_SIGNATURE_OK:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DUMP_PROGRAMMING_INTERFACE USES GV;
    INTEGER PROGRAMMODE =INT(SHARED_BUFFER[295..288]);
    IF ( ! (PROGRAMMODE==1) ) THEN GOTO NOT_JTAG_PM;
    PRINT "Programming Mode: JTAG";
    NOT_JTAG_PM:
    IF ( ! (PROGRAMMODE==2) ) THEN GOTO NOT_IAP_PM;
    PRINT "Programming Mode: IAP";
    NOT_IAP_PM:
    IF ( ! (PROGRAMMODE==3) ) THEN GOTO NOT_SPI_SLAVE_PM;
    PRINT "Programming Mode: SPI_SLAVE";
    NOT_SPI_SLAVE_PM:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DUMP_DEBUG_INFO USES GV,CONSTBLOCK,DUMP_PROGRAMMING_INTERFACE;
    INTEGER TMPINT =0;
    PRINT "---------------------------------------";
    EXPORT "DEBUG_INFO", SHARED_BUFFER[671..0];
    PRINT "CYCLE COUNT: ",INT(SHARED_BUFFER[495..480]);
    CALL DUMP_PROGRAMMING_INTERFACE;
    BUFF32[31..0] = SHARED_BUFFER[287..256];
    TMPINT = INT(BUFF32[5..0]);
    IF ( ! ( (TMPINT==0)||(TMPINT==63)) ) THEN GOTO NOT_UNDEF;
    PRINT "Algorithm Version:";
    NOT_UNDEF:
    IF ( ! ( (TMPINT!=0)&&(TMPINT!=63)) ) THEN GOTO UNDEF;
    PRINT "Algorithm Version: ",INT(BUFF32[5..0]);
    UNDEF:
    TMPINT = INT(BUFF32[9..6]);
    IF ( ! (TMPINT==SELF) ) THEN GOTO NOT_SELF;
    PRINT "Programmer: SPI Master Auto Programming";
    NOT_SELF:
    IF ( ! (TMPINT==SCULPTW) ) THEN GOTO NOT_SCULPTW;
    PRINT "Programmer: Silicon Sculptor II/III";
    NOT_SCULPTW:
    IF ( ! (TMPINT==BPWIN) ) THEN GOTO NOT_BPW;
    PRINT "Programmer: BP Programmer";
    NOT_BPW:
    IF ( ! (TMPINT==ACTEL_IHP) ) THEN GOTO NOT_ACTEL_IHP;
    PRINT "Programmer: Actel IHP";
    NOT_ACTEL_IHP:
    IF ( ! (TMPINT==FP3) ) THEN GOTO NOT_FP3;
    PRINT "Programmer: FlashPro3";
    NOT_FP3:
    IF ( ! (TMPINT==FP4) ) THEN GOTO NOT_FP4;
    PRINT "Programmer: FlashPro4";
    NOT_FP4:
    IF ( ! (TMPINT==FP5) ) THEN GOTO NOT_FP5;
    PRINT "Programmer: FlashPro5";
    NOT_FP5:
    IF ( ! (TMPINT==FP6) ) THEN GOTO NOT_FP6;
    PRINT "Programmer: FlashPro6";
    NOT_FP6:
    IF ( ! (TMPINT==EFP6) ) THEN GOTO NOT_EFP6;
    PRINT "Programmer: Embedded FlashPro6";
    NOT_EFP6:
    IF ( ! (TMPINT==SIL_EXPL) ) THEN GOTO NOT_SIL_EXPL;
    PRINT "Programmer: Silicon Explorer";
    NOT_SIL_EXPL:
    IF ( ! (TMPINT==ATE) ) THEN GOTO NOT_ATE;
    PRINT "Programmer: Non Actel Programmer";
    NOT_ATE:
    IF ( ! ( (TMPINT==0)||(TMPINT==15)) ) THEN GOTO UNDEF_P_T;
    PRINT "Programmer:";
    UNDEF_P_T:
    TMPINT = INT(BUFF32[22..17]);
    IF ( ! (TMPINT==FP34) ) THEN GOTO NOT_FP34;
    PRINT "Software Version: FlashPro v3.4";
    NOT_FP34:
    IF ( ! (TMPINT==FP40) ) THEN GOTO NOT_FP40;
    PRINT "Software Version: FlashPro v4.0";
    NOT_FP40:
    IF ( ! (TMPINT==FP41) ) THEN GOTO NOT_FP41;
    PRINT "Software Version: FlashPro v4.1";
    NOT_FP41:
    IF ( ! (TMPINT==FP42) ) THEN GOTO NOT_FP42;
    PRINT "Software Version: FlashPro v4.2";
    NOT_FP42:
    IF ( ! (TMPINT==FP50) ) THEN GOTO NOT_FP50;
    PRINT "Software Version: FlashPro v5.0";
    NOT_FP50:
    IF ( ! (TMPINT==FP51) ) THEN GOTO NOT_FP51;
    PRINT "Software Version: FlashPro v5.1";
    NOT_FP51:
    IF ( ! (TMPINT==FP60) ) THEN GOTO NOT_FP60;
    PRINT "Software Version: FlashPro v6.0";
    NOT_FP60:
    IF ( ! (TMPINT==FP61) ) THEN GOTO NOT_FP61;
    PRINT "Software Version: FlashPro v6.1";
    NOT_FP61:
    IF ( ! (TMPINT==FP62) ) THEN GOTO NOT_FP62;
    PRINT "Software Version: FlashPro v6.2";
    NOT_FP62:
    IF ( ! (TMPINT==FP84) ) THEN GOTO NOT_FP84;
    PRINT "Software Version: FlashPro v8.4";
    NOT_FP84:
    IF ( ! (TMPINT==FP85) ) THEN GOTO NOT_FP85;
    PRINT "Software Version: FlashPro v8.5";
    NOT_FP85:
    IF ( ! (TMPINT==FP86) ) THEN GOTO NOT_FP86;
    PRINT "Software Version: FlashPro v8.6";
    NOT_FP86:
    IF ( ! (TMPINT==FP90) ) THEN GOTO NOT_FP90;
    PRINT "Software Version: FlashPro v9.0";
    NOT_FP90:
    IF ( ! (TMPINT==FP91) ) THEN GOTO NOT_FP91;
    PRINT "Software Version: FlashPro v9.1";
    NOT_FP91:
    IF ( ! (TMPINT==FP_10_LCP) ) THEN GOTO NOT_10_LCP;
    PRINT "Software Version: FlashPro 10.0 LCP";
    NOT_10_LCP:
    IF ( ! (TMPINT==FP_11_BETA_SPA) ) THEN GOTO NOT_11_BETA_SPA;
    PRINT "Software Version: FlashPro 11.0 Beta SPA";
    NOT_11_BETA_SPA:
    IF ( ! (TMPINT==FP_11_BETA_SP1) ) THEN GOTO NOT_11_BETA_SP1;
    PRINT "Software Version: FlashPro 11.0 Beta SP1";
    NOT_11_BETA_SP1:
    IF ( ! (TMPINT==FP_11) ) THEN GOTO NOT_11;
    PRINT "Software Version: FlashPro 11.0";
    NOT_11:
    IF ( ! (TMPINT==FP_11_1) ) THEN GOTO NOT_11_1;
    PRINT "Software Version: FlashPro 11.1";
    NOT_11_1:
    IF ( ! (TMPINT==FP_11_2) ) THEN GOTO NOT_11_2;
    PRINT "Software Version: FlashPro 11.2";
    NOT_11_2:
    IF ( ! (TMPINT==FP_11_3) ) THEN GOTO NOT_11_3;
    PRINT "Software Version: FlashPro 11.3";
    NOT_11_3:
    IF ( ! (TMPINT==FP_11_4) ) THEN GOTO NOT_11_4;
    PRINT "Software Version: 11.4";
    NOT_11_4:
    IF ( ! (TMPINT==FP_11_5) ) THEN GOTO NOT_11_5;
    PRINT "Software Version: 11.5";
    NOT_11_5:
    IF ( ! (TMPINT==FP_11_6) ) THEN GOTO NOT_11_6;
    PRINT "Software Version: 11.6";
    NOT_11_6:
    IF ( ! (TMPINT==FP_11_7) ) THEN GOTO NOT_11_7;
    PRINT "Software Version: 11.7";
    NOT_11_7:
    IF ( ! (TMPINT==FP_11_8) ) THEN GOTO NOT_11_8;
    PRINT "Software Version: 11.8";
    NOT_11_8:
    IF ( ! (TMPINT==FP_G5_EAP4_SPA) ) THEN GOTO NOT_G5_EAP4_SPA;
    PRINT "Software Version: PolarFire v1.1";
    NOT_G5_EAP4_SPA:
    IF ( ! (TMPINT==FP_PF_1_1_SP1) ) THEN GOTO NOT_FP_1_1_SP1;
    PRINT "Software Version: PolarFire v1.1 SP1";
    NOT_FP_1_1_SP1:
    IF ( ! (TMPINT==FP_PF_2_0) ) THEN GOTO NOT_FP_PF_2_0;
    PRINT "Software Version: PolarFire v2.0";
    NOT_FP_PF_2_0:
    IF ( ! (TMPINT==FP_PF_2_1) ) THEN GOTO NOT_FP_PF_2_1;
    PRINT "Software Version: PolarFire v2.1";
    NOT_FP_PF_2_1:
    IF ( ! (TMPINT==FP_PF_2_2) ) THEN GOTO NOT_FP_PF_2_2;
    PRINT "Software Version: PolarFire v2.2";
    NOT_FP_PF_2_2:
    IF ( ! (TMPINT==FP_PF_2_3) ) THEN GOTO NOT_FP_PF_2_3;
    PRINT "Software Version: PolarFire v2.3";
    NOT_FP_PF_2_3:
    IF ( ! (TMPINT==FP_12_0) ) THEN GOTO NOT_FP_12_0;
    PRINT "Software Version: 12.0";
    NOT_FP_12_0:
    IF ( ! (TMPINT==FP_12_1) ) THEN GOTO NOT_FP_12_1;
    PRINT "Software Version: 12.1";
    NOT_FP_12_1:
    IF ( ! (TMPINT==FP_12_2) ) THEN GOTO NOT_FP_12_2;
    PRINT "Software Version: 12.2";
    NOT_FP_12_2:
    IF ( ! (TMPINT==FP_12_3) ) THEN GOTO NOT_FP_12_3;
    PRINT "Software Version: 12.3";
    NOT_FP_12_3:
    IF ( ! (TMPINT==FP_12_4) ) THEN GOTO NOT_FP_12_4;
    PRINT "Software Version: 12.4";
    NOT_FP_12_4:
    IF ( ! (TMPINT==FP_12_5) ) THEN GOTO NOT_FP_12_5;
    PRINT "Software Version: 12.5";
    NOT_FP_12_5:
    IF ( ! (TMPINT==FP_12_6) ) THEN GOTO NOT_FP_12_6;
    PRINT "Software Version: 12.6";
    NOT_FP_12_6:
    IF ( ! (TMPINT==FP_2021_1) ) THEN GOTO NOT_FP_2021_1;
    PRINT "Software Version: 2021.1";
    NOT_FP_2021_1:
    IF ( ! (TMPINT==FP_2021_2) ) THEN GOTO NOT_FP_2021_2;
    PRINT "Software Version: 2021.2";
    NOT_FP_2021_2:
    IF ( ! (TMPINT==FP_2021_3) ) THEN GOTO NOT_FP_2021_3;
    PRINT "Software Version: 2021.3";
    NOT_FP_2021_3:
    IF ( ! (TMPINT==FP_2022_1) ) THEN GOTO NOT_FP_2022_1;
    PRINT "Software Version: 2022.1";
    NOT_FP_2022_1:
    IF ( ! (TMPINT==FP_2022_2) ) THEN GOTO NOT_FP_2022_2;
    PRINT "Software Version: 2022.2";
    NOT_FP_2022_2:
    IF ( ! (TMPINT==FP_2022_3) ) THEN GOTO NOT_FP_2022_3;
    PRINT "Software Version: 2022.3";
    NOT_FP_2022_3:
    IF ( ! (TMPINT==FP_2023_1) ) THEN GOTO NOT_FP_2023_1;
    PRINT "Software Version: 2023.1";
    NOT_FP_2023_1:
    IF ( ! ( (TMPINT==0)||(TMPINT==63)) ) THEN GOTO NOT_UNDEF_SOFT_VER;
    PRINT "Software Version:";
    NOT_UNDEF_SOFT_VER:
    TMPINT = INT(BUFF32[25..23]);
    IF ( ! (TMPINT==FP) ) THEN GOTO NOT_FP;
    PRINT "Programming Software: FlashPro";
    NOT_FP:
    IF ( ! (TMPINT==DIRECTC) ) THEN GOTO NOT_DC;
    PRINT "Programming Software: Direct C";
    NOT_DC:
    IF ( ! (TMPINT==FPX) ) THEN GOTO NOT_FPX;
    PRINT "Programming Software: FlashPro Express";
    NOT_FPX:
    IF ( ! (TMPINT==NON_ACTEL) ) THEN GOTO NOT_NON_ACTEL;
    PRINT "Programming Software: Non Actel SW";
    NOT_NON_ACTEL:
    IF ( ! ( (TMPINT==0)||(TMPINT==7)) ) THEN GOTO UNDEF_P_S;
    PRINT "Programming Software:";
    UNDEF_P_S:
    TMPINT = INT(BUFF32[31..29]);
    IF ( ! (TMPINT==PPD) ) THEN GOTO NOT_PPD;
    PRINT "Programming File Type: PPD";
    NOT_PPD:
    IF ( ! (TMPINT==STAPL) ) THEN GOTO NOT_STAPL;
    PRINT "Programming File Type: STAPL";
    NOT_STAPL:
    IF ( ! (TMPINT==SVF) ) THEN GOTO NOT_SVF;
    PRINT "Programming File Type: SVF";
    NOT_SVF:
    IF ( ! (TMPINT==PCF) ) THEN GOTO NOT_PCF;
    PRINT "Programming File Type: PCF";
    NOT_PCF:
    IF ( ! (TMPINT==IEEE1532) ) THEN GOTO NOT_IEEE1532;
    PRINT "Programming File Type: IEEE 1532";
    NOT_IEEE1532:
    IF ( ! ( (TMPINT==0)||(TMPINT==7)) ) THEN GOTO UNDEF_P_F_T;
    PRINT "Programming File Type:";
    UNDEF_P_F_T:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_UDV USES GV,DO_EXIT;
    BOOLEAN READ_UDV_RESULT[32];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $cd;
    DRSCAN 32, $00000000;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 32, $00000000, CAPTURE READ_UDV_RESULT[];
        IF ( ! (READ_UDV_RESULT[31]==0) ) THEN GOTO UDV_POLL;
        IPOLL = 0;
        PASS = 1;
        UDV_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_UDV_DONE;
        IRSCAN 8, $cd;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_UDV_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO UDV_PASS;
    PRINT "Instruction timed out while reading udv.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    UDV_PASS:
    PRINT "Die Firmware Version: ",INT(READ_UDV_RESULT[15..8]),".",INT(READ_UDV_RESULT[7..0]);
    EXPORT "UDV", READ_UDV_RESULT[31..0];
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_DESIGN_INFO USES GV,DO_EXIT,READ_SHARED_BUFFER;
    BOOLEAN READ_DESIGN_INFO_RESULT[8];
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $a6;
    DRSCAN 8, $00;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 8, $00, CAPTURE READ_DESIGN_INFO_RESULT[];
        IF ( ! (READ_DESIGN_INFO_RESULT[7]==0) ) THEN GOTO READ_DESIGN_INFO_POLL;
        IPOLL = 0;
        PASS = 1;
        READ_DESIGN_INFO_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_DESIGN_INFO_DONE;
        IRSCAN 8, $a6;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_DESIGN_INFO_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO READ_DESIGN_INFO_PASS;
    PRINT "Instruction timed out while reading design information.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_DESIGN_INFO_PASS:
    IBLOCKS = 3;
    CALL READ_SHARED_BUFFER;
    PRINT "Design Name: ",CHR$(INT(SHARED_BUFFER[23..16])),CHR$(INT(SHARED_BUFFER[31..24]))
        ,CHR$(INT(SHARED_BUFFER[39..32])),CHR$(INT(SHARED_BUFFER[47..40])),CHR$(INT(SHARED_BUFFER[55..48]))
        ,CHR$(INT(SHARED_BUFFER[63..56])),CHR$(INT(SHARED_BUFFER[71..64])),CHR$(INT(SHARED_BUFFER[79..72]))
        ,CHR$(INT(SHARED_BUFFER[87..80])),CHR$(INT(SHARED_BUFFER[95..88])),CHR$(INT(SHARED_BUFFER[103..96]))
        ,CHR$(INT(SHARED_BUFFER[111..104])),CHR$(INT(SHARED_BUFFER[119..112])),CHR$(INT(SHARED_BUFFER[127..120]))
        ,CHR$(INT(SHARED_BUFFER[135..128])),CHR$(INT(SHARED_BUFFER[143..136])),CHR$(INT(SHARED_BUFFER[151..144]))
        ,CHR$(INT(SHARED_BUFFER[159..152])),CHR$(INT(SHARED_BUFFER[167..160])),CHR$(INT(SHARED_BUFFER[175..168]))
        ,CHR$(INT(SHARED_BUFFER[183..176])),CHR$(INT(SHARED_BUFFER[191..184])),CHR$(INT(SHARED_BUFFER[199..192]))
        ,CHR$(INT(SHARED_BUFFER[207..200])),CHR$(INT(SHARED_BUFFER[215..208])),CHR$(INT(SHARED_BUFFER[223..216]))
        ,CHR$(INT(SHARED_BUFFER[231..224])),CHR$(INT(SHARED_BUFFER[239..232])),CHR$(INT(SHARED_BUFFER[247..240]))
        ,CHR$(INT(SHARED_BUFFER[255..248]));
    EXPORT "CHECKSUM", SHARED_BUFFER[15..0];
    EXPORT "READ_DESIGN_INFO: ", SHARED_BUFFER[287..0];
    EXPORT "DESIGNVER", SHARED_BUFFER[271..256];
    EXPORT "BACKLEVEL", SHARED_BUFFER[287..272];
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_VERIFY_DIGEST USES GV,DO_EXIT,READ_SHARED_BUFFER,DO_QUERY_SECURITY;
    BOOLEAN CHECK_DIGESTS_RESULT[16];
    BOOLEAN CHECK_DIGESTS_INPUT[16];
    INTEGER FACTORY_DIGEST_ERROR =0;
    INTEGER DIGEST_ERROR =0;
    CALL DO_QUERY_SECURITY;
    IF ( ! (SHARED_BUFFER[10]==1) ) THEN GOTO EXT_DIGEST_NOT_LOCKED;
    PRINT "External digest check via JTAG/SPI Slave is disabled.";
    STATUS = -18;
    UNIQUEEXITCODE = 32787;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    EXT_DIGEST_NOT_LOCKED:
    CHECK_DIGESTS_INPUT[0] = 1;
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $bc;
    DRSCAN 16, CHECK_DIGESTS_INPUT[15..0];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 16, $0000, CAPTURE CHECK_DIGESTS_RESULT[15..0];
        IF ( ! (CHECK_DIGESTS_RESULT[15]==0) ) THEN GOTO CHECK_DIGESTS_POLL;
        IPOLL = 0;
        PASS = 1;
        CHECK_DIGESTS_POLL:
        IF ( ! (PASS==0) ) THEN GOTO CHECK_DIGESTS_DONE;
        IRSCAN 8, $bc;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        CHECK_DIGESTS_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO CHECK_DIGESTS_NOT_TIMED_OUT;
    PRINT "Instruction timed out while verifying digest.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    CHECK_DIGESTS_NOT_TIMED_OUT:
    IF ( ! ( (PASS==1)&&(CHECK_DIGESTS_RESULT[14]==1)) ) THEN GOTO CHECK_DIGESTS_PASS;
    PRINT "Failed while running verify digest.";
    STATUS = -19;
    UNIQUEEXITCODE = 32788;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    CHECK_DIGESTS_PASS:
    IBLOCKS = 26;
    CALL READ_SHARED_BUFFER;
    IF ( ! (CHECK_DIGESTS_RESULT[0]==1) ) THEN GOTO CHECK_FABRIC_FAIL;
    PRINT "CHECK FABRIC digest verification: PASS";
    CHECK_FABRIC_FAIL:
    IF ( ! (CHECK_DIGESTS_RESULT[0]==0) ) THEN GOTO CHECK_FABRIC_PASS;
    PRINT "CHECK FABRIC digest verification: FAIL";
    DIGEST_ERROR = 1;
    CHECK_FABRIC_PASS:
    EXPORT "CHECK FABRIC digest", SHARED_BUFFER[255..0];
    IF ( ! (CHECK_DIGESTS_RESULT[1]==1) ) THEN GOTO CC_FAIL;
    PRINT "CC digest verification: PASS";
    CC_FAIL:
    IF ( ! (CHECK_DIGESTS_RESULT[1]==0) ) THEN GOTO CC_PASS;
    PRINT "CC digest verification: FAIL";
    DIGEST_ERROR = 1;
    CC_PASS:
    EXPORT "CC digest", SHARED_BUFFER[511..256];
    IF ( ! (CHECK_DIGESTS_RESULT[2]==1) ) THEN GOTO SNVM_FAIL;
    PRINT "SNVM digest verification: PASS";
    SNVM_FAIL:
    IF ( ! (CHECK_DIGESTS_RESULT[2]==0) ) THEN GOTO SNVM_PASS;
    PRINT "SNVM digest verification: FAIL";
    DIGEST_ERROR = 1;
    SNVM_PASS:
    EXPORT "SNVM digest", SHARED_BUFFER[767..512];
    IF ( ! (CHECK_DIGESTS_RESULT[12]==1) ) THEN GOTO SYS_FAIL;
    PRINT "SYS digest verification: PASS";
    SYS_FAIL:
    IF ( ! (CHECK_DIGESTS_RESULT[12]==0) ) THEN GOTO SYS_PASS;
    PRINT "SYS digest verification: FAIL";
    DIGEST_ERROR = 1;
    FACTORY_DIGEST_ERROR = 1;
    SYS_PASS:
    EXPORT "SYS digest", SHARED_BUFFER[3327..3072];
    PRINT "Please refer to PolarFire/PolarFire SoC Security User Guide for more details about different digests.";
    IF ( ! (FACTORY_DIGEST_ERROR==1) ) THEN GOTO SYS_PASS2;
    STATUS = -20;
    UNIQUEEXITCODE = 32796;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    SYS_PASS2:
    IF ( ! (DIGEST_ERROR==1) ) THEN GOTO DIGEST_PASS;
    STATUS = -20;
    UNIQUEEXITCODE = 32795;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    DIGEST_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_READ_DUMP_DIBS USES GV,DO_EXIT,READ_SHARED_BUFFER;
    PASS = 0;
    BOOLEAN READ_DIBS_RESULT[128];
    BOOLEAN FACTORY_INTEGRITY_VALUE[256];
    FACTORY_INTEGRITY_VALUE[255..0] = $4be48dc078655d410fcdce9bf440e55e2fab9525a27eb8f1e4b1db5c9d0caff6;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $e1;
    DRSCAN 128, $5c72316ace9e47de771c4f0105d870b4;
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 100000 TO 0 STEP -1;
        DRSCAN 128, $5c72316ace9e47de771c4f0105d870b4, CAPTURE READ_DIBS_RESULT[];
        IF ( ! (READ_DIBS_RESULT[127]==0) ) THEN GOTO READ_DIBS_POLL;
        IPOLL = 0;
        PASS = 1;
        READ_DIBS_POLL:
        IF ( ! (PASS==0) ) THEN GOTO READ_DIBS_DONE;
        IRSCAN 8, $e1;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        READ_DIBS_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    IF ( ! (PASS==0) ) THEN GOTO READ_DIBS_NOT_TIMED_OUT;
    PRINT "Instruction timed out while reading device integrity bits.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_DIBS_NOT_TIMED_OUT:
    IF ( ! (READ_DIBS_RESULT[0]==1) ) THEN GOTO READ_DIBS_PASS;
    PRINT "Error reading device integrity bits.";
    STATUS = 7;
    UNIQUEEXITCODE = 33003;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    READ_DIBS_PASS:
    IBLOCKS = 11;
    CALL READ_SHARED_BUFFER;
    EXPORT "Factory Integrity Bits", FACTORY_INTEGRITY_VALUE[255..0];
    EXPORT "Device Integrity Bits", SHARED_BUFFER[255..0];
    INTEGER COUNTER =0;
    FOR I = 0 TO 224 STEP 32;
        IF ( ! (INT(FACTORY_INTEGRITY_VALUE[(I+31)..I])==INT(SHARED_BUFFER[(I+31)..I])) ) THEN GOTO Label_10;
        COUNTER = (COUNTER+1);
        Label_10:
        LABEL_SEPARATOR = 0;
    NEXT I;
    IF ( ! (COUNTER==8) ) THEN GOTO Label_11;
    PRINT "Device Integrity Status : PASS";
    Label_11:
    IF ( ! (COUNTER!=8) ) THEN GOTO Label_12;
    PRINT "Device Integrity Status : FAIL";
    Label_12:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_DEVICE_INFO USES GV,READ_DSN,DO_EXIT,DO_DUMP_SECURITY,DO_READ_TVS_MONITOR
    ,DO_READ_DEBUG_INFO,DO_READ_DIGESTS,DUMP_DEBUG_INFO,DO_READ_UDV,DO_READ_DESIGN_INFO
    ,DO_READ_DUMP_DIBS;
    PRINT "Die Revision: ",IDREV;
    CALL DO_READ_UDV;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0e;
    WAIT IDLE, 1 CYCLES;
    DRSCAN 32, $00000000, CAPTURE BUFF32[];
    IF ( ! (INT(BUFF32[31..0])==-1) ) THEN GOTO NOT_EMPTY_SILSIG;
    BUFF32[31..0] = $00000000;
    NOT_EMPTY_SILSIG:
    EXPORT "SILSIG", BUFF32[];
    IRSCAN 8, $0d, CAPTURE BUFF32[7..0];
    CALL DO_READ_DIGESTS;
    IF ( ! (BUFF32[7]==1) ) THEN GOTO CORE_NOT_ENABLED;
    PRINT "FPGA Array is programmed and enabled.";
    CALL DO_READ_DESIGN_INFO;
    CORE_NOT_ENABLED:
    IF ( ! (BUFF32[7]==0) ) THEN GOTO CORE_ENABLED;
    PRINT "FPGA Array is not enabled.";
    CORE_ENABLED:
    CALL DO_READ_DEBUG_INFO;
    CALL DUMP_DEBUG_INFO;
    CALL READ_DSN;
    IF ( ! (READ_SN_RESULT[128]==1) ) THEN GOTO FSN_NOT_BUSY;
    CALL DO_EXIT;
    FSN_NOT_BUSY:
    CALL DO_READ_TVS_MONITOR;
    CALL DO_DUMP_SECURITY;
    CALL DO_READ_DUMP_DIBS;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE PROC_ENABLE USES GV,DO_EXIT,DO_UNLOCK_KEYS;
    CALL DO_UNLOCK_KEYS;
    BOOLEAN ISC_ENABLE_RESULT[32];
    BPGMMODE = 1;
    PASS = 0;
    BSR[1633..0] = BSRPATTERN[1633..0];
    BOOLEAN SHIFT_DATA[1634];
    IRSCAN 8, $01;
    DRSCAN 1634, BSR[];
    WAIT IDLE, 1 CYCLES;
    DRSCAN 1634, SHIFT_DATA[], CAPTURE SAMPLE_DEVICE[];
    FOR I = 0 TO 1633;
        IF ( ! (SAMPLEMASK[I]==1) ) THEN GOTO NOT_SAMPLE_MASK;
        BSR[I] = SAMPLE_DEVICE[I];
        NOT_SAMPLE_MASK:
        LABEL_SEPARATOR = 0;
    NEXT I;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $01;
    DRSCAN 1634, BSR[];
    WAIT IDLE, 1 CYCLES;
    BOOLEAN TOOLINFO[32];
    TOOLINFO[5..0] = ACT_UROW_ALGO_VERSION[5..0];
    TOOLINFO[9..6] = ACT_UROW_PROGRAM_SW[3..0];
    TOOLINFO[22..17] = ACT_UROW_SW_VERSION[5..0];
    TOOLINFO[25..23] = ACT_UROW_PGM_SW[2..0];
    TOOLINFO[28..26] = BOOL(3);
    TOOLINFO[31..29] = BOOL(2);
    PASS = 0;
    IRSTOP IRPAUSE;
    DRSTOP DRPAUSE;
    IRSCAN 8, $0b;
    DRSCAN 32, TOOLINFO[];
    WAIT IDLE, 3 CYCLES;
    WAIT 10 USEC, DRPAUSE;
    FOR IPOLL = 1000000 TO 0 STEP -1;
        DRSCAN 32, $00000000, CAPTURE ISC_ENABLE_RESULT[31..0];
        IF ( ! (ISC_ENABLE_RESULT[31]==0) ) THEN GOTO ISC_ENABLE_POLL;
        IPOLL = 0;
        PASS = 1;
        ISC_ENABLE_POLL:
        IF ( ! (PASS==0) ) THEN GOTO ISC_ENABLE_DONE;
        IRSCAN 8, $0b;
        WAIT IRPAUSE, 10 USEC, IRPAUSE;
        ISC_ENABLE_DONE:
        LABEL_SEPARATOR = 0;
    NEXT IPOLL;
    EXPORT "ISC_ENABLE_RESULT", ISC_ENABLE_RESULT[];
    EXPORT "CRCERR", ISC_ENABLE_RESULT[0..0];
    IF ( ! (PASS==0) ) THEN GOTO ISC_ENABLE_NOT_TIMED_OUT;
    PRINT "Instruction timed out while entering programming mode.";
    STATUS = -32;
    UNIQUEEXITCODE = 32818;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    CALL DO_EXIT;
    ISC_ENABLE_NOT_TIMED_OUT:
    IF ( ! ( (PASS==1)&&(ISC_ENABLE_RESULT[0]==1)) ) THEN GOTO ISC_ENABLE_PASS;
    PRINT "Failed to enter programming mode.";
    UNIQUEEXITCODE = 32771;
    BUFF32[15..0] = BOOL(UNIQUEEXITCODE);
    EXPORT "ERROR_CODE", BUFF32[15..0];
    STATUS = 5;
    CALL DO_EXIT;
    ISC_ENABLE_PASS:
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE INIT_VARIABLES_FOR_ACTION USES GV;
    LABEL_SEPARATOR = 0;
ENDPROC;

PROCEDURE DO_CHECK_CYCLE_COUNT USES GV,DO_READ_DEBUG_INFO;
    INTEGER CYCLECOUNT =0;
    INTEGER MAXCYCLECOUNT =500;
    CALL DO_READ_DEBUG_INFO;
    CYCLECOUNT = INT(SHARED_BUFFER[495..480]);
    IF ( ! ( (CYCLECOUNT>=(MAXCYCLECOUNT-50))&&(CYCLECOUNT<MAXCYCLECOUNT)) ) THEN GOTO NOT_LAST_CYCLE_COUNT;
    PRINT "Info: You are ",(MAXCYCLECOUNT-CYCLECOUNT)," cycles away from maximum programming cycle count of "
        ,MAXCYCLECOUNT," on this device. Refer to your device datasheet for more details.";
    NOT_LAST_CYCLE_COUNT:
    IF ( ! (CYCLECOUNT==MAXCYCLECOUNT) ) THEN GOTO WARN_CYCLE_COUNT;
    PRINT "Info: You are in the last cycle to reach maximum programming cycle count of "
        ,MAXCYCLECOUNT," on this device. Refer to your device datasheet for more details.";
    WARN_CYCLE_COUNT:
    IF ( ! (CYCLECOUNT>MAXCYCLECOUNT) ) THEN GOTO NO_WARN_CYCLE_COUNT;
    PRINT "Warning: You have exceeded the maximum programming cycle count of ",MAXCYCLECOUNT
        ," on this device. Refer to your device datasheet for more details.";
    NO_WARN_CYCLE_COUNT:
    LABEL_SEPARATOR = 0;
ENDPROC;


CRC 9FA4;
